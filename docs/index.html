<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SlotNVM: SlotNVM</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SlotNVM
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classSlotNVM.html">SlotNVM</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>I was looking for a way to store different data with different size to EEPROM where the size is only known at runtime. Also data should not get lost if a write access was interrupted. Most libraries I found can handle only compile time fixed data size or writes are not transactional or are not suitable for Arduino. This library should implement this as an Arduino library.</p>
<p>Two possible solutions come to my mind. The first is a block based organization. There is a lot of extra data needed and if you don't need a full block some bytes could remain unused. In contrast it is robust. If one block is defect all other could still be OK. An other solution is a heap implementation. There is less overhead and no unused bytes. But such an implementation is a little bit more difficult and if one structure is defect all data behind this is lost or at least not allocateable.</p>
<p>This repository implement a block based EEPROM structure. Later also Flash access could added, therefore I will write about NVM from now. The NVM is split into blocks of equal size, called clusters. You do not access this clusters directly but store your data in virtual slots. Such a slot is indicate by a number and can be placed in any of the clusters or also in more than one.</p>
<h2>Features</h2>
<p>Currently implemented:</p>
<ul>
<li>Support for Arduino buildin EEPROM</li>
<li>Extendable to other EEPROM using own access class</li>
<li>Transactional write</li>
<li>Possibility to reserve some free clusters to ensure that data can always safely be rewritten</li>
<li>Possibility to enable wear leveling via random function</li>
<li>Low RAM usage</li>
<li>Up to 32KiByte EEPROM (128 clusters with 256 bytes or 256 clusters with 128 byte each)</li>
<li>Up to 250 slots</li>
<li>1 to 256 bytes per slot (0 byte not allowed)</li>
<li>Possibility to reduce maximum slots to reduce RAM usage</li>
<li>Use you own 8 bit CRC function (no xor in/out or reflect out)</li>
<li>Possibility to disable CRC for more available user data</li>
</ul>
<p>Currently not implemented:</p>
<ul>
<li>Flash memory</li>
<li>CRC xor in/out or reflect out (and will never implement?)</li>
<li>Non transactional write as optional fallback</li>
<li>Use more than 8 bits for slot data length</li>
</ul>
<h2>Usage</h2>
<p>For AVR microcontroller based Arduino boards with integrated EEPROM you can use one of the following classes.</p>
<ul>
<li><code><a class="el" href="classSlotNVM16noCRC.html" title="SlotNVM with 16 bytes per cluster and no CRC. ">SlotNVM16noCRC</a>&lt;&gt;</code></li>
<li><code><a class="el" href="classSlotNVM32noCRC.html" title="SlotNVM with 32 bytes per cluster and no CRC. ">SlotNVM32noCRC</a>&lt;&gt;</code></li>
<li><code><a class="el" href="classSlotNVM64noCRC.html" title="SlotNVM with 64 bytes per cluster and no CRC. ">SlotNVM64noCRC</a>&lt;&gt;</code></li>
<li><code><a class="el" href="classSlotNVM16CRC.html" title="SlotNVM with 16 bytes per cluster protected with CRC. ">SlotNVM16CRC</a>&lt;&gt;</code></li>
<li><code><a class="el" href="classSlotNVM32CRC.html" title="SlotNVM with 32 bytes per cluster protected with CRC. ">SlotNVM32CRC</a>&lt;&gt;</code></li>
<li><code><a class="el" href="classSlotNVM64CRC.html" title="SlotNVM with 64 bytes per cluster protected with CRC. ">SlotNVM64CRC</a>&lt;&gt;</code></li>
</ul>
<p>Excample code: </p><pre class="fragment">// Include the header
#include &lt;SlotNVM.h&gt;

// Create an instance
SlotNVM16CRC&lt;&gt; slotNVM;

int starts = 1;

void setup() {
  Serial.begin(115200);

  // Call begin() once
  slotNVM.begin();
  // Init random generator for better wear leveling
  randomSeed(analogRead(0));

  // Now you can use readSlot() and writeSlot()
  if (slotNVM.readSlot(1, starts)) {
    Serial.print(F("This is start no. "));
    Serial.println(starts);
  } else {
    Serial.println(F("This is the first start"));
  }

  if (starts &lt; 3) {
    ++starts;
    slotNVM.writeSlot(1, starts);
  }
}

void loop() {
}
</pre><p>Transactional write is implemented by first write the new data and than delete the old one. Therefore you need some free space if you want to overwrite a slot. If you want to ensure that you can always rewrite data you can create a <a class="el" href="classSlotNVM.html">SlotNVM</a> with reserved space. You are not able to use this reserved space to write in an empty slot. This feature is useful for configuration data. Otherwise you are not able to change your configuration if <a class="el" href="classSlotNVM.html">SlotNVM</a> is full of other data. </p><pre class="fragment">#include &lt;SlotNVM.h&gt;

// struct for my configuration
struct configuration {
  char name[10];
  int  age;
};

const char DEF_NAME[] PROGMEM = "Arduino";
const int  DEF_AGE = 42;

configuration myConfig;

// Create an instance
// This SlotNVM reserves some space to always
// allow to rewrite slot data with the size
// up to the same size like configuration.
SlotNVM32CRC&lt;sizeof(configuration)&gt; slotNVM;

const uint8_t CFG_SLOT = slotNVM.S_LAST_SLOT;

void setup() {
  Serial.begin(115200);

  // Call begin() once
  slotNVM.begin();
  // Init random generator for better wear leveling
  randomSeed(analogRead(0));

  if (!slotNVM.readSlot(CFG_SLOT, myConfig)) {
    // No configuration stored, use default
    Serial.println(F("Default configuration used"));
    strcpy_P(myConfig.name, DEF_NAME);
    myConfig.age = DEF_AGE;

    // Note: Reservation works only for rewriting
    // a slot not for the first write.
    // If you want to ensure to change this
    // configuration you should write it
    // before there is no space left.
    slotNVM.writeSlot(CFG_SLOT, myConfig);
  } else {
    Serial.println(F("Configuration was loaded"));
  }

  // Use other slots for your business
  for (uint8_t slot = 1; slot &lt; CFG_SLOT; ++slot) {
    if (slotNVM.isSlotAvailable(slot)) {
      // Do something with this slot
      Serial.print(F("Slot "));
      Serial.print(slot);
      Serial.println(F(" has some data."));
    }
  }
}

void loop() {
}
</pre><p>The following tables should help to choose the right class. As you can see smaller cluster allows more slots but reduces usable memory size.</p>
<table class="doxtable">
<tr>
<th><a class="el" href="classSlotNVM.html">SlotNVM</a> class </th><th>CRC </th><th align="right">Bytes / cluster </th><th align="right">User data / cluster </th><th align="right">Usable data / %  </th></tr>
<tr>
<td>SlotNVM16noCRC&lt;&gt; </td><td>no </td><td align="right">16 </td><td align="right">11 </td><td align="right">68,8% </td></tr>
<tr>
<td>SlotNVM32noCRC&lt;&gt; </td><td>no </td><td align="right">32 </td><td align="right">27 </td><td align="right">84,4% </td></tr>
<tr>
<td>SlotNVM64noCRC&lt;&gt; </td><td>no </td><td align="right">64 </td><td align="right">59 </td><td align="right">92,2% </td></tr>
<tr>
<td>SlotNVM16CRC&lt;&gt; </td><td>yes </td><td align="right">16 </td><td align="right">10 </td><td align="right">62,5% </td></tr>
<tr>
<td>SlotNVM32CRC&lt;&gt; </td><td>yes </td><td align="right">32 </td><td align="right">26 </td><td align="right">81,3% </td></tr>
<tr>
<td>SlotNVM64CRC&lt;&gt; </td><td>yes </td><td align="right">64 </td><td align="right">58 </td><td align="right">90,6% </td></tr>
</table>
<p>Arduino Nano Every 256 bytes EEPROM</p>
<table class="doxtable">
<tr>
<th><a class="el" href="classSlotNVM.html">SlotNVM</a> class </th><th align="right">Clusters </th><th align="right">Slots </th><th align="right">Usable size / bytes </th><th align="right">RAM usage / byte  </th></tr>
<tr>
<td>SlotNVM16noCRC&lt;&gt; </td><td align="right">16 </td><td align="right">16 </td><td align="right">176 </td><td align="right">5 </td></tr>
<tr>
<td>SlotNVM32noCRC&lt;&gt; </td><td align="right">8 </td><td align="right">8 </td><td align="right">216 </td><td align="right">3 </td></tr>
<tr>
<td>SlotNVM64noCRC&lt;&gt; </td><td align="right">4 </td><td align="right">4 </td><td align="right">236 </td><td align="right">3 </td></tr>
<tr>
<td>SlotNVM16CRC&lt;&gt; </td><td align="right">16 </td><td align="right">16 </td><td align="right">160 </td><td align="right">5 </td></tr>
<tr>
<td>SlotNVM32CRC&lt;&gt; </td><td align="right">8 </td><td align="right">8 </td><td align="right">208 </td><td align="right">3 </td></tr>
<tr>
<td>SlotNVM64CRC&lt;&gt; </td><td align="right">4 </td><td align="right">4 </td><td align="right">232 </td><td align="right">3 </td></tr>
</table>
<p>Arduino Uno / Genuino, Nano, Leonardo, Micro with 1024 bytes EEPROM</p>
<table class="doxtable">
<tr>
<th><a class="el" href="classSlotNVM.html">SlotNVM</a> class </th><th align="right">Clusters </th><th align="right">Slots </th><th align="right">Usable size / bytes </th><th align="right">RAM usage / byte  </th></tr>
<tr>
<td>SlotNVM16noCRC&lt;&gt; </td><td align="right">64 </td><td align="right">64 </td><td align="right">704 </td><td align="right">17 </td></tr>
<tr>
<td>SlotNVM32noCRC&lt;&gt; </td><td align="right">32 </td><td align="right">32 </td><td align="right">864 </td><td align="right">9 </td></tr>
<tr>
<td>SlotNVM64noCRC&lt;&gt; </td><td align="right">16 </td><td align="right">16 </td><td align="right">944 </td><td align="right">5 </td></tr>
<tr>
<td>SlotNVM16CRC&lt;&gt; </td><td align="right">64 </td><td align="right">64 </td><td align="right">640 </td><td align="right">17 </td></tr>
<tr>
<td>SlotNVM32CRC&lt;&gt; </td><td align="right">32 </td><td align="right">32 </td><td align="right">832 </td><td align="right">9 </td></tr>
<tr>
<td>SlotNVM64CRC&lt;&gt; </td><td align="right">16 </td><td align="right">16 </td><td align="right">928 </td><td align="right">5 </td></tr>
</table>
<p>Arduino Mega with 4096 bytes EEPROM</p>
<table class="doxtable">
<tr>
<th><a class="el" href="classSlotNVM.html">SlotNVM</a> class </th><th align="right">Clusters </th><th align="right">Slots </th><th align="right">Usable size / bytes </th><th align="right">RAM usage / byte  </th></tr>
<tr>
<td>SlotNVM16noCRC&lt;&gt; </td><td align="right">256 </td><td align="right">250 </td><td align="right">2816 </td><td align="right">65 </td></tr>
<tr>
<td>SlotNVM32noCRC&lt;&gt; </td><td align="right">128 </td><td align="right">128 </td><td align="right">3456 </td><td align="right">33 </td></tr>
<tr>
<td>SlotNVM64noCRC&lt;&gt; </td><td align="right">64 </td><td align="right">64 </td><td align="right">3776 </td><td align="right">17 </td></tr>
<tr>
<td>SlotNVM16CRC&lt;&gt; </td><td align="right">256 </td><td align="right">250 </td><td align="right">2560 </td><td align="right">65 </td></tr>
<tr>
<td>SlotNVM32CRC&lt;&gt; </td><td align="right">128 </td><td align="right">128 </td><td align="right">3328 </td><td align="right">33 </td></tr>
<tr>
<td>SlotNVM64CRC&lt;&gt; </td><td align="right">64 </td><td align="right">64 </td><td align="right">3712 </td><td align="right">17 </td></tr>
</table>
<p>If non of the classes abouve fits you needs or if you use a non AVR microcontroller or you want to use external EEPROM you need to use the class <a class="el" href="classSlotNVM.html">SlotNVM</a>. Also you need to implement an access class. As a template you can use <a class="el" href="classNVMBase.html" title="Use this as base for your NVM access class. ">NVMBase</a> or <a class="el" href="classArduinoEEPROM.html" title="NVM access class for AVR microcontroller with integrated EEPROM. ">ArduinoEEPROM</a>. </p><pre class="fragment">// Include the header
#include &lt;SlotNVM.h&gt;
#include &lt;MyAccessClass.h&gt;

// Create an instance, with
//   no provision
//   default slot count (based on cluster count)
//   no CRC
//   default random function (rand())
SlotNVM&lt;MyAccessClass, 32&gt; slotNVM;

void setup() {
  Serial.begin(115200);

  // Call begin() once
  slotNVM.begin();
  // Init random generator for better wear leveling
  srand(analogRead(0));

  // ...
}
</pre><h2>Install</h2>
<p>Just download the code as zip file. In GitHub click on the <code>[Code]</code>-button and select <code>Download ZIP</code>.</p>
<p>In Arduino IDE select <code>Sketch</code> -&gt; <code>Include library</code> -&gt; <code>Add ZIP Library ...</code> to add the downloaded ZIP file.</p>
<h2>License</h2>
<p><a class="el" href="classSlotNVM.html">SlotNVM</a> is distributed under the [MIT License](LICENSE). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
